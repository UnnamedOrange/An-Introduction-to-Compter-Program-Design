# 第四章 C 语言中的数据与控制

## 第一节 数据类型

### 第一小节 二进制补码

前面已经讲过使用一个字节表示 0 到 255 的无符号整数。无符号整数表示法：
$$
a_7 \times 2^7 + a_6 \times 2^6 + \cdots + a_1 \times 2^1 + a_0 \times 2^0
$$
同理，可以使用四个字节表示 0 到 $2^{32} - 1$ 的无符号整数。

下面考虑使用二进制数表示可正可负的整数。以一个字节的整数为例，假设一开始是非负的，如上面的式子所示。要表示负数，可以将上式修改为：
$$
-a_7 \times 2^7 + a_6 \times 2^6 + \cdots + a_1 \times 2^1 + a_0 \times 2^0
$$
即：将最高位的权重从 $2^7$ 变为 $-2^7$。这就是整数的补码表示。计算机中的有符号整数都使用**补码（two's complement）**表示（指 CPU 的指令处理有符号整数时都认为它们是补码表示，也有别的地方用到了反码表示）。分析：

1. 最大数，所有正权重为 1，负权重为 0，等于 127。
2. 最小数，……。-128
3. 全为 0 时，等于 0。
4. 全为 1 时，等于 -1。
5. $a_7, a_6, \ldots, a_0$ 的取值与它们表示的数一一对应，因为定义域和值域都恰好有 $256$ 个元素。
6. 最高位表示符号位：当 $a_7 = 1$ 时，表示的数一定是负数；否则一定是非负数。

更多位数的整数同理。$N$ 位**有符号整数范围**是 $-2^{N - 1} \sim 2^{N - 1} - 1$。

补码表示法下求相反数。方法：把这个 $N$ 位二进制数看作无符号数，然后用 $2^{N}$ 减去它，得到的结果就是原二进制数的相反数。补码的补字就由此而来。

求相反数的另一种方法（最常见的说法）：

1. 将原二进制数的所有位取反（1 变 0，0 变 1）。
2. 将得到的新二进制数加一，则得到了原数的相反数。

为什么另一种方法等价于前面较为数学的方法：

1. 第一步相当于是用 $2^N - 1$（二进制位全是 1）减去原二进制数。
2. 第二步就是加 $1$。

**补码表示法的重要特点**：一个有符号整数在进行加减法时也可以看作一个无符号整数，因为它们的加减法运算是完全相同的。相比前面，这一点最重要，因为这涉及有符号数和无符号数之间的类型转换。

注：一般规定：非负数的补码就是它自身，负数的补码是使用以上方法求得的新数。所以前面叫做“求相反数”，没有叫做“求补码”。

反码（one's complement）表示法。求反码：规定将原二进制数的所有位取反，即得到原二进制数的相反数。问题：不是一一对应的，有两个 $0$。

### 第二小节 整数类型

`short`：有符号整数，长度一般为 2 个字节。

`int`：有符号整数，规定长度不小于 `short` 的长度。个人计算机上，`int` 的长度一般为 4 个字节。

`long int`（一般写作 `long`，这一点说明基础类型名可能不止一个单词）：有符号整数，规定长度不小于 `int` 的长度。个人计算机上，`long` 的长度一般为 4 个字节。

`long long int`（一般写作 `long long`）：有符号整数。个人计算机上 `long long` 的长度一般为 8 个字节（$-2^{63} \sim 2^{63} - 1$）。

无符号整数：只需要在类型前面加上 `unsigned`。

也可以单写 `unsigned`，则表示 `unsigned int`。

`printf` 与 `scanf`。`%d` `%lld`。

`sizeof` 运算符。

定长整数类型。

```c
#include <stdint.h>
int8_t a;
uint32_t b;
```

### 第三小节 字符类型

字符也是数，只是人们设定了标准，指明了哪个数对应哪个字符，你的程序不用知道具体的对应关系。

`char`：字符型整数，长度为 1 个字节。是否有符号无所谓，由编译器决定。当使用 `char` 保存字符时，是否有符号也不重要。

如果只是要保存长度为 1 个字节的整数，就需要指明是否有符号，无符号就是 `unsigned char`，有符号是 `signed char`。

为类型定义别名。`typedef 原类型 新类型`。作用域？

```c
typedef unsigned char byte;
```

字符字面量。字面量（literals）：直接写出来的常量。用单引号括起来。

```c
char ch = 'a';
```

注意与字符串字面量区分。字符字面量是单引号，字符串字面量是双引号。目前，只用掌握在 `printf` 等函数中使用字符串字面量的方法。

字符字面量的类型就是字符类型。里面只能写 [ASCII 码](https://baike.baidu.com/item/ASCII/309296)中的字符，因为字符类型的值仅 1 个字节长。在下一章（使用海量存储器）中讨论复杂字符的处理。

转义字符。有些字符不好写，用转义：

```c
"\n\t\r\x41\\" // 换行，制表符，回车，A（A 的 ASCII 码是 65，十六进制是 0x41）
```

- 转义字符：字符串字面量相关的概念，所有字符串字面量都要用转义字符。
- 格式化说明符（`%d`）：`printf, scanf` 相关的概念，在 `printf, scanf` 的内部进行处理。



如果是使用字符类型存长度为 1 个字节的整数，则会用到整数字面量。

- 十六进制整数字面量：`0x` 开头。
- 八进制整数字面量：`0` 开头。一般不用。注意不要给十进制数加前导零，否则就变成八进制了！

整数字面量可以指定类型，方法是在结尾加上额外字符。

```c
114514; // 不加是 int。
114514114514; // int 存不下默认是 long long。
114514l; // long。
114514u; // unsigned。
114514LL; // long long。
```

`u` 和 `l` 或者 `ll` 可以混用，顺序无所谓。后缀的大小写也无所谓。当使用 `l` 时，建议使用大写，避免与 `1` 混淆。



使用 `%c` 输出单个字符。

```c
char ch = 'A';
printf("%c", ch);
```

不要使用 `scanf("%c", &ch)`，会把换行等也读入，产生各种各样的问题。

输出单个字符的 ASCII 码。直接使用 `%d` 就可以。

\*为什么？前面不是说长度要匹配吗（参见 `%d, %lld`）？

### 第四小节 浮点数类型

使用**二进制科学计数法**表示的小数，称为浮点数。CPU 有计算浮点数的电路。不要求掌握浮点数的结构和特殊浮点数。

`float`（32 位浮点数），`double`（64 位浮点数），`long double`（64 位浮点数，一般不用）。`sizeof`。

`float` 字面量：`0.0f`，`0.0F`（以 `f` 结尾）不写就是默认 `double`。

`%f`，`%lf`。`%.3f`。

浮点误差。`0.1 + 0.2 != 0.3`。浮点数不适合直接用等号来比较相等。

## 第二节 比较运算符与逻辑运算符

### 第一小节 比较运算符

`>, >=, <, <=, ==, !=`。

比较浮点数相等的方法。

```c
#include <stdio.h>
#include <math.h>

int main()
{
	const double epsilon = 1e-9;
	if (fabs((0.1 + 0.2) - (0.3)) < epsilon)
	{
		printf("相等");
	}
}
```

连续的比较运算符：一般都是错的。计算方法是把 `==` 看成类似于 `+` 的运算符，一个一个计算，含义并非是连等。

比较运算符的运算结果：真为 `1`，假为 `0`，类型为 `int`。

### 第二小节 逻辑运算符

`&&, ||, !`。掌握优先级（先与后或）和结合性（自左向右）。

\*使用真值表分析逻辑。C 语言应该没这个必要，仅供初学者了解。

虽然要求掌握优先级，但编译器可能会警告缺少括号。打上括号没有坏处。

**短路计算。**一旦表达式的值确定，就不会再运算。典型例子：

```c
if (!is_empty() && check()); // 如果为空，则不进行后续操作。不为空才会进行 check。
```

注意区分按“逻辑与（或）”与“按位与（或）”的区别。

运算结果：真为 `1`，假为 `0`，类型为 `int`。

## 第三节 循环结构程序设计

### 第一小节 `while` 循环与 `do-while` 循环

```c
while (条件)
{
    循环体;
}
```

语法上与 `if` 完全一致，不同的是，最后一个执行完后，`if` 语句不再跳转，而 `while` 语句会跳转到条件判断处。

```c
do
{
    循环体;
} while (条件); // 有个分号。
```

逻辑上等价于：

```c
循环体;
while (条件)
{
    循环体;
}
```



例：（在 Windows 操作系统中）不断判断鼠标是否在屏幕左上角，一旦放在了屏幕左上角则停止。

分析：鼠标是由操作系统管理的外部设备，只能通过调用操作系统提供函数获取鼠标位置。

解：

```c
#include <stdio.h>
#include <Windows.h>

int get_is_mouse_topleft()
{
	POINT pt;
	GetCursorPos(&pt);
	return pt.x == 0 && pt.y == 0;
}

int main()
{
	while (!get_is_mouse_topleft())
	{
		printf("waiting\n");
	}
}
```

或者不写函数。但因为整个判断过程比较复杂，无法在一个括号内完成，所以可以用 `do-while`。

```c
#include <stdio.h>
#include <Windows.h>

int main()
{
	int is_mouse_topleft;
	do
	{
		POINT pt;
		GetCursorPos(&pt);
		is_mouse_topleft = pt.x == 0 && pt.y == 0;

		printf("waiting\n");
	} while (!is_mouse_topleft);
}
```



做计算时，不会调用操作系统的函数获取程序外部的状态，程序的运行状态完全由程序自己定义的变量决定。这时继续循环（或者说结束循环）的条件一般会在一次循环结束前进行计算。

```c
while (条件)
{
	循环体;
    调整条件相关的变量。
}
```

例如，**输出整数 1 到 n。**

```c
int n = 10;
int to_output = 1; // 要输出的数，从 1 开始。
while (to_output <= n) // 要输出的数小于等于 n 才输出，否则终止。
{
    {
        printf("%d\n", to_output);
    }
    {
        to_output = to_output + 1;
    }
}
```

### 第二小节 `for` 循环

可以认为 `for` 是 `while` 的高级包装。**最常用 `for` 循环遍历整数 1 到 n。**

```c
for (int i = 1; i <= n; i++) // i++ 的意思是 i = i + 1
{
    printf("%d\n", i);
}
```

其中变量 `i` 的作用域是 `for` 的大括号内。另外，最常用 `for` 循环遍历整数 0 到 n - 1。

```c
for (int i = 0; i < n; i++)
{
	printf("%d\n", i);
}
```

可以看出，`for (A; B; C)` 等价于：

```c
A;
while (B)
{
    循环体;
    C;
}
```

但也不完全等价。目前已经能看出来的区别有：

1. A, B, C 对于 `for` 而言只能写一条语句（一个分号算一条语句）。如果真的有多种要求，用逗号运算符（A 和 C 的运算结果没有用，但 B 的运算结果被用来进行判断）。
2. A 处定义变量的作用域不同。如果要定义变量，for 在 A 定义的变量必须是同一类型的（因为只能写一条语句）。

之后还能看到更多不同。

例题：

1. P57，3n+1 问题。[C# 版本](https://www.bilibili.com/read/cv13408017)。

2. P54，aabb 问题。只看第一种解法。

   嵌套 `for` 循环。

### 第三小节 在循环中进行受控强制跳转

在循环中，如果我们想要立刻终止循环，可以写 `break`。

```c
break;
```

如果我们想要立刻进行下一次条件判断，可以写 `continue`。

```c
continue;
```

1. `while (1)-break` 结构。

   条件总是为真，故如果没有 `break` 语句，则循环会一直进行下去。例：编写程序找到第一个非负的某某数。

   ```c
   int num = 0;
   while (1)
   {
       if (是某某数(num))
           break;
       num++;
   }
   printf("%d\n", num);
   ```

   或者用 `for` 实现以上功能。

   ```c
   // int num; // 为什么不写在 `for` 里面？假设 for 之后要用，就不要写里面了。
   for (int num = 0; ; num++)
   {
       if (是某某数(num))
       {
           printf("%d\n", num);
           break;
       }
   }
   ```

   当 `for` 的 B 为空时，表示条件总是为真。A 和 C 也能为空，但分号不能省。

2. `do-while(0)-break` 结构。

   条件总是为假，则等价于不写 `do-while`。

   ```c
   do
   {
       循环体;
   } while (0);
   ```

   等价于：

   ```c
   {
       循环体; // 其实没有循环。
   }
   ```

   但好处是，前者可以使用 `break`，而后者不能。前者多了一个受控跳转的目的地。

   ```c
   do
   {
       if (不适合继续计算)
           break;
       else if (继续计算)
   } while (0);
   ```

   注意 `break` 只能用于循环结构，不能用于分支结构。

3. `continue` 对于 `for` 和 `while` 不同。

   ```c
   int i = 0;
   while (i < 10)
   {
       if (i == 3)
           continue; // 跳过了 i++，死循环！
      	printf("%d\n", i);
      	i++;
   }
   ```

   ```c
   for (int i = 0; i < 10; i++)
   {
       if (i == 3)
           continue; // 跳过循环体，但会在执行 C 后再判断！
      	printf("%d\n", i);
   }
   ```

例题：

1. P54，aabb 问题。只看第二种解法。
2. 求 n 个数中的最大数。

嵌套循环以习题的形式出现。

### 第四小节 程序运行时间分析初步

例题：

1. 输入一个数 `n`，判断是否为质数。

   暴力法：执行的指令数不超过 $100 n + c$，则当 $n \to \infty$ 时，执行的指令数可以被 $n$ 的有限倍数控制，记为 $O(n)$。

   开根号法：执行的指令数不超过 $100 \sqrt{n} + c$，则当 $n \to \infty$ 时，执行的指令数可以被 $\sqrt{n}$ 的有限倍数控制，记为 $O(\sqrt{n})$。

   $O(f(n))$ 更数学的说法：存在一个实数 $M$ 和一个整数 $N$，当 $n > N$ 时，有 $\text{指令数}(n) \le M \times f(n)$。

   可见，$O(n)$ 是一种比较宽松的说法，是一个上界：有可能一个程序执行的指令数不超过 $100 n^{0.99}$，也可以记为 $O(n)$。我们尽量去接近上确界的结果。

   称 $O(f(n))$ 为程序的渐进时间复杂度。所谓渐进，考虑的是当 $n$ “很大”时的情况。时间复杂度能够反映程序的运行时间与数据规模的变化关系。更关键的，时间复杂度可以用来估算数据规模较大时程序的运行时间。

2. P62，阶乘之和。

   结论：分析时可以忽略系数以及低次项，也可以保留以供他人阅读。
   $$
   S \bmod 1000000
   $$
   
   ```c
   S % 1000000
   ```
   
   每次重新用循环计算阶乘，时间复杂度是 $O(n^2)$。
   
   用一个变量记录上次计算的阶乘，时间复杂度是 $O(n)$。
   
   **避免重复计算。**

