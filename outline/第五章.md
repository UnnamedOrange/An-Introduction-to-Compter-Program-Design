# 第五章 使用海量存储器

## 第一节 数组

### 第一小节 定义与访存数组

数组和普通变量在原理上没有区别。定义数组的语法：

```c
元素类型 数组名[数组大小];
```

- 数组作为局部变量。

  ```c
  int main()
  {
      int a_number;
      int an_array[10];
  }
  ```

  前者在栈中占用 4 字节的空间，后者在栈中占用 40 字节的空间，并且是连续的 40 字节。因为两者都没有赋初值，所以两者的初始值都是不确定的。（调试）

- 数组作为全局变量或静态变量。

  ```c
  int a_number;
  int an_array[10];
  int main() {}
  ```

  ```c
  int main()
  {
      static int a_number;
      static int an_array[10];
  }
  ```

  两者的初始值都默认为 0。（调试）

讨论：使用 `sizeof` 获取数组的大小（**不是元素个数**）。数组占用的**字节数**！

```c
sizeof(an_array) / sizeof(an_array[0])
```

初始化数组：

```c
int a[] = {1, 0, 4, 2}, b[10] = {0};
```

不能把 `an_array` 看作一个长度为 40 字节的整数。数组不是头等公民，不能执行数组间的四则运算、赋值运算。

```c
int a[10], b[10];
// a + b, a - b, a = b // 错误的。
```

要访存数组中的数据，必须以数组元素为基本单位进行操作。访问数组的第 `i` 个元素的语法：

```c
数组名[i]
```

`i` 从零开始计数。



例题：输入 1000 个数，然后按相反的顺序输出它们。

思路：第一个要输出的数是最后一个数，那就必须把前面输入的数全部存下来。

```c
#include <stdio.h>

int main()
{
    int numbers[10];
    for (int i = 0; i < 10; i++)
        scanf("%d", &numbers[i]);
    for (int i = 9; i >= 0; i--)
        printf("%d ", numbers[i]);
}
```

讨论：

1. 复习从 `0` 到 `n - 1` 的循环的写法。

2. 从 `n - 1` 到 `0` 的循环的写法。问题：`i` 必须是有符号整数，为什么？

   ```c
   for (unsigned int i = 9; ~i; i--)
   ```

3. 将数组定义为局部变量。把 10 换成 100000 后，数组必须定义为全局变量或静态变量，因为栈空间的大小是有限的。

4. 如果在程序内部需要把数组反转一下，应该怎么写？

   ```c
   #include <stdio.h>
   
   int main()
   {
   	int a[10];
   	int n = 7;
   	for (int i = 0; i < n; i++)
   		a[i] = i;
   	for (int i = 0, j = n - 1; i < j; i++, j--)
   	{
   		int temp = a[i];
   		a[i] = a[j];
   		a[j] = temp;
   	}
   }
   ```

   ```c
   	for (int i = 0; i < 10; i++)
   		b[9 - i] = a[i];
   	for (int i = 0; i < 10; i++)
   		a[i] = b[i]
   ```



例题：P83 开灯问题。讨论：

1. 题目的数据规模不再是固定的，而是输入的 `n` 个。要注意什么？

   - **数组的大小不能是变量。**
   - 数组的大小应该是多少？能否定义为局部变量？

2. 逻辑上，下标从 1 开始，方便思考多了。

   - 数组的大小至少是多少？

3. 数组的初始化。

   ```c
   int main()
   {
       int a[100] = {0};
   }
   ```

   没写的初始值默认为零。

### 第二小节 二维数组

内存是一列长长的表。我们怎么存储 $n$ 行 $m$ 列的表格？一个思路是：把这 $n$ 行拼接起来，上一行的末尾连接这一行的头部，则 $n$ 行 $m$ 列的二维表格就变成了一个长度为 $n \times m$ 的一列表。

例题：$3 \times 3$ 表格。一开始一行一行地输入这个表格，然后输入一个行号，一个列号，要求输出对应位置的元素。

样例输入：

```
1 2 3
4 5 6
7 8 9
2 3
```

样例输出：

```
6
```

解释：第二行第三列是 `6`。

分析：用上述方法存储数据，则输入时就是输入九个数。

```c
#include <stdio.h>
int main()
{
    int table[3 * 3];
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
        	scanf("%d", &table[i * 3 + j]);
    int row, col;
    scanf("%d%d", &row, &col);
    row -= 1;
    col -= 1;
    printf("%d\n", table[row * 3 + col]);
}
```

讨论：

1. 题目中下标从 1 开始，符合人的思维习惯。代码中下标从 0 开始，便于写程序（从 0 开始，不用加一减一）。
2. **使用 `行号 * 列数 + 列号` 从二维坐标转换为一维坐标。**
3. 输入时其实可以用单重循环。
4. C 语言中提供自然的语法，不用我们写 `行号 * 列数 + 列号`，我们只需要写 `[行号][列号]`。

定义二维数组的语法：

```c
元素类型 数组名[行数][列数];
```

用二维数组重写上一题：

```c
#include <stdio.h>
int main()
{
    int table[3][3];
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
        	scanf("%d", &table[i][j]);
    int row, col;
    scanf("%d%d", &row, &col);
    row -= 1;
    col -= 1;
    printf("%d\n", table[row][col]);
}
```

可以认为，后面的程序是前面程序的逻辑简化版，`table` 变量的空间结构在两个程序中是一样的，只是在两个程序使用了不同的 C 语言语法。

更高维的数组也同理。

例题：P84 蛇形填数

思路：笔。

讨论：

1. 这道题完全是二维的，没有必要用一维的思路去考虑。C 语言提出了多维数组的概念，利用编译器隐藏了将多维数组一维化的过程。
2. 这道题是目前为止讲过的最难的题，难在思路。



例题：矩阵乘法。$n \times m$ 矩阵是一个 $n$ 行 $m$ 列的数表。$n \times m$ 的矩阵 $A$ 与 $m \times k$ 的矩阵 $B$ 之间可以定义乘法，运算结果是一个 $n \times k$ 的矩阵 $C$。$C$ 的元素 `C[i][j]` 的运算规则是（下标从 $0$ 开始）：
$$
C[i][j] = \sum\limits_{l = 1}^m A[i][l] \cdot B[l][j]
$$
输入两个 $n \times n$ 的矩阵，输出它们乘法的结果。

样例输入：

```
2
1 1
1 1
2 2
2 2
```

样例输出：

```
4 4
4 4
```

```c
#include <stdio.h>
int main()
{
    int A[10][10], B[10][10], C[10][10] = {0};
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &A[i][j]);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &B[i][j]);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int l = 0; l < n; l++)
                C[i][j] += A[i][l] * B[l][j];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            printf("%d ", C[i][j]);
        printf("\n");
    }
}
```

### \*第三小节 程序的空间局部性

方阵乘法的核心代码：

```c
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
        for (int l = 0; l < n; l++)
            C[i][j] += A[i][l] * B[l][j];
```

发现：这三重循环可以任意交换顺序，最后计算的结果保持不变。不变的原因：每一个 `i, j, l` 会对 `C[i][j]` 有贡献，交换顺序并不影响每一个贡献，只是改变了贡献顺序。

问题：交换顺序将影响程序运行速度。

最好是：

```c
for (int i = 0; i < n; i++)
    for (int l = 0; l < n; l++)
    	for (int j = 0; j < n; j++)
            C[i][j] += A[i][l] * B[l][j];
```

该程序：对 `B` 的访问是一维的，对 `A` 的访问也是一维的。从左到右依次访问，充分利用缓存。

程序的空间局部性：假设程序经常在最近访问的内存的附近进行访存。据此假设，硬件设计了缓存结构，如果程序真的满足空间局部性，硬件会使得程序的运行速度大幅提升。

改进后的程序：对于 `A` 和 `B`，总是访问相邻的内存。

原程序：每次访问 `B` 时，会跳跃 `maxn * 4` 个字节，不连续。

## 第二节 指向数据的指针

### 第一小节 指针即地址

回忆：使用 `scanf` 进行输入时，我们要把被输入的变量的地址交给 `scanf`，在 `scanf` 内部才知道把输入的数据放到哪儿。

回忆：地址：内存是随机访问的，每一个存储单元有一个地址，所有存储单元排成一个长列表。

`&A`：`&` 是取地址运算符，`A` 是一个左值（可以取地址的值），例如，单写一个变量名就是一个左值。

`&A` 是一个表达式，这个表达式的值显然是 `A` 的地址（address），但是什么类型？C 语言中，保存地址的类型称为**指针（pointer）**类型，本质上是一个整数，但 C 语言提出了单独的指针类型，以保证程序逻辑清晰。

指针类型的长度。所有指针类型的长度都一样，具体长度多少取决于处理器架构。

- `x86`：32 位。（32 位程序）指针长 4 字节。
- `x64`：64 位。（64 位程序）指针长 8 字节。

不知道类型的指针用 `void*` 表示。`printf` 使用 `%p` 输出指针。

```c
#include <stdio.h>

int main()
{
    int a;
    void* p = &a;
    printf("%p", p);
}
```

`void*` 这个类型不携带额外信息，编译器只知道这是一个指针。除了把这个指针当做一个数之外，编译器不知道其他任何事情。换言之，`void*` 类型的指针只能用于：

1. 转换为整数类型，然后当作一个数进行计算。
2. 转换为具体的指针类型，然后当作一个有具体类型的指针使用。这个具体类型由程序员在后续代码中指定。

为什么要学习指针：

1. 把地址告诉别人，别人能够帮我们填充数据（`scanf`）（`memset` 留作作业题）。
2. 指针运算与访问数组元素相关联。访问数组元素：计算地址（指针），根据计算出的地址取值。
3. 本节是指向数据的指针。还有指向代码的指针。

### 第二小节 有具体类型的指针

有具体类型的指针可以取值。

```c
#include <stdio.h>

int main()
{
    int a = 114514;
    int* p = &a;
    printf("%d\n", *p);
}
```

取值运算符 `*A`。有具体类型的指针知道自己指向的数据的类型，就知道要检查的存储器的长度以及计算结果的类型。`void*` 类型不能被取值，因为不知道具体类型。

有具体类型的指针还能进行加减法。指针 +- 数：往后（前）移动 `n` 个元素（而不是移动多少字节）。指针 - 指针：两个指针之间的元素数量。

### 第三小节 数组向指针的隐式转换

数组变量向指针发生隐式转换。数组作为二等公民不能作为参数被传递，你看到的所有参数一定都不是数组。如果需要提升为一等公民，则会隐式转换为指针，指向第一个变量。

数组最重要的额外属性是它的大小。

```c
int a[10];
int* p = a;
```

讨论：

1. `sizeof(a)`，`sizeof(p)`

2. `int* p, x;`，`p` 和 `x` 的类型是什么？一次只定义一个变量。

3. `a + 1`？

   ```c
   	int n = 10;
   	int a[10];
   	for (int i = 0; i < n; i++)
   	{
   		scanf("%d", a + i);
   		scanf("%d", &a[i]);
   	}
   ```



指向指针的指针。

```c
int* a[10]; // 含有 10 个指针的指针数组。
int** p = a; // p 是一个指针，指向指针。
```

不懂没关系，因为可以使用别名简化其中的逻辑。

```c
int main()
{
    typedef int* pointer_of_int;
    pointer_of_int a[10];
    pointer_of_int* p = a;
}
```



\*高维数组发生隐式转换时，类型会更复杂。

```c
int main()
{
    int a[10][10];
    int(*p1)[10] = a;
    int* p2 = a[0];
}
```

\*讨论：

1. `int(*p1)[10]` 的类型是 `int (*)[10]`，表示指向长度为 `10` 的数组的指针。
2. `a[0]` 写出来表示一个长度为 `10` 的数组（`sizeof(a[0])`），还没有被降级为指针。

结论：太复杂，不要求掌握，没啥用。

## 第三节 字符串

### 第一小节 以零结尾的字符数组

C 语言中，字符数组就是字符串。字符串不过是一系列字符连在了一起。

```c
char str[100];
```

“烫烫烫烫烫烫烫烫烫”？调试看看。烫的含义：`0xcccccccc`，调试时没有初始化的变量。

输入字符串的格式化说明符：`%s`。注意：使用 `scanf` 输入字符串时，空格是分隔符。

```c
scanf("%s", str); // 数组向指针的隐式转换。
```

实验表明，以下代码都可以：

```c
scanf("%s", str); // 数组向指针的隐式转换。
scanf("%s", &str); // 主动取地址
```

C 语言中一般规定：字符串在逻辑上的长度不使用额外的变量保存，而是在字符串的结尾后放置一个 `0` 元素作为终止标记。如果要使用系统提供的函数，则必须遵守这个规则。上面两行代码，输入 `114514` 调试。

例题：统计输入的字符串的长度。字符串中不含空格回车等 `scanf` 的分隔符。长度一定不超过 100。

样例输入：

```
114514
```

样例输出：

```
6
```

分析：使用 `scanf` 输入的字符串总是以零结尾。使用一个循环一直走，直到遇到零。

```c
#include <stdio.h>

int main()
{
	char str[105];
	scanf("%s", str);
	int count = 0;
	while (str[count] != 0)
		count++;
	printf("%d\n", count);
}
```

讨论：

1. 本题数组开 100 够吗？
2. 本题 `str` 有必要在定义的同时初始化吗？
3. 使用 `for` 循环重写本题。

### 第二小节 字符串字面量

就是在代码中直接写出的字符串。转义字符的规则与字符字面量相同。

```c
"%d\n"
```

```c
"The answer is 42."
```

讨论：

1. 字符串字面量的类型？可以认为是 `const char*`，即**就是一个指针**，并且指向的区域不可写（`const` 之后有机会再讲）。

2. `sizeof`？说明并不完全是 `const char*`，但我们认为是 `const char*`，因为使用字符串字面量时总是会被转换为 `const char*`。（一般我们不会对字符串字面量使用 `sizeof`）

3. 字符串字面量的数据存在哪儿？

   ```c
   #include <stdio.h>
   
   int main()
   {
   	char* a = "1";
   	a[0] = '2';
   	printf("%s", a);
   }
   ```

   在 Debug 和 Release 里分别看看有啥区别。

   结论：内存中的一个只读区（复习虚拟内存的功能）。说明了将字符串字面量看作一个指针的合理性。

   讨论：整数字面量的数据存在哪儿？以立即数的形式放在汇编指令里。



初始化字符数组。回忆，对于整数：

```c
int main()
{
	int a[5]; // 未初始化
	int b[5] = { 1, 2, 3 }; // 1, 2, 3, 0, 0
	int c[] = { 1, 2, 3 }; // 1, 2, 3
}
```

如果在定义的同时初始化，则可以省去数组的大小，此时规定数组的大小等于初始化列表中元素的个数。

由于字符类型也是整数，所以同样可以这样初始化。

```c
int main()
{
	char a[5]; // 未初始化
	char b[5] = { 1, 2, '3' }; // 1, 2, 51, 0, 0
	char c[] = { '1', '2', '3' }; // 49, 50, 51
}
```

使用字符串字面量初始化字符数组。为了方便，可以直接用字符串字面量初始化字符数组。

```c
int main()
{
	char str1[100] = "123"; // 多余的元素同样为 0
	char str2[] = "123"; // 多长？
}
```

讨论：

1. 使用初始化列表初始化字符数组，与使用字符串字面量初始化字符数组的区别？主要区别：以零结尾。

2. 定义的同时初始化与赋值是不同的。

   ```c
   char str[] = "123";
   str = "456"; // 错误，数组本身不能进行任何赋值
   ```



例题：[洛谷 P1914 凯撒密码](https://www.luogu.com.cn/problem/P1914)。

思路：处理每一个字符，遇到零就停止处理，然后直接输出原数组。定义一个数组，保存：

```c
char table[] = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
```

找到位置后，往后移动 n 位就可以了。

讨论：

1. 非常灵活，还可以一个一个读入、处理、输出。看看大家的题解就发现八仙过海。

   利用 ASCII 码的相关知识，可以怎么做？

2. 以下两句代码有什么区别？

   ```c
   char table[] = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
   ```

   ```c
   const char* table = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
   ```

### 第三小节 常用字符串相关函数

复习调用函数的语法。调用函数的作用：调用别人封装好的函数，减少你的工作；调用操作系统提供的函数，使你的程序能够访问虚拟内存之外的资源。

#### 字符串处理

`printf, scanf`：目标一般为屏幕上的控制台。

`sprintf, sscanf`：目标为字符串。

```c
char str[100];
printf("%d", 42); // 在屏幕上输出 42
sprintf(str, "%d", 42); // str 变成了 "42"
```

讨论：`"42"` 只**占用了 3 个字节**，调用 `sprintf` 后，后面的字节变成了什么？ 

```c
int x;
char str[100] = "42";
scanf("%d", &x); // 在控制台中输入一个数
sscanf(str, "%d", &x); // x 变成了 42
sscanf("42", "%d", &x); // 同上
```



下面要包含 `string.h`，并且你的字符串一定要以零结尾。

```c
#include <string.h>
```

获取字符串长度：

```c
char str[100] = "abc";
strlen(str); // 3
```

拷贝字符串：

```c
char des[100], src[100] = "abc";
strcpy(des, src);
```

按字典序比较字符串：

```c
char a[100] = "abc", b[100] = "edg";
strcmp(a, b); // 0 表示相等，1 表示大于，-1 表示小于
```

#### 输入输出

`getchar`，`putchar`：读入一个字符（各种字符都算）；输出一个字符。

读入一行：

```c
char buf[100];
fgets(buf, 100, stdin);
```

会多一个换行符！注意额外判断。

```c
char str[100] = "abc";
puts(str); // 自动补一个换行。
```

#### 例题

[洛谷 P5015 标题统计](https://www.luogu.com.cn/problem/P5015)

```c
#include <stdio.h>
#include <string.h>

char str[1000005];

int main()
{
	fgets(str, 1000005, stdin);
	int ans = 0;
	for (int i = 0, len = strlen(str); i < len; i++)
		if (str[i] != ' ' && str[i] != '\n')
			ans++;
	printf("%d\n", ans);
}
```

讨论：

1. `for` 循环时，`strlen` 就是 `n`。

   但这么写有大问题！不要每次在判断时求字符串长度！

2. 记住 `fgets` 后面有一个 `\n`。 

3. 为什么数据规模与约定这么复杂？

   只是为了给小朋友多一些分数。如果你只会 `scanf` 和 `strlen`，你也能得到 80 分。

   分数是对比赛而言的。对于学习者而言，除非题目特别难，否则 80 分也按 0 分处理。

   ```c
   #include <stdio.h>
   #include <string.h>
   
   int main()
   {
   	char str[10];
   	scanf("%s", str);
   	printf("%d\n", (int)strlen(str)); // 为什么要强制转换为 int？
   }
   ```

### 第四小节 国际化

前面处理的字符串都使用的是 ASCII 码，ASCII 码中不能包含汉字。

实验：

```c
#include <stdio.h>
int main()
{
	printf("你好，世界！");
}
```

```c
#include <stdio.h>
int main()
{
	putchar('你'); // 字符型字面量是 int。
}
```

查看：

```c
#include <stdio.h>
#include <string.h>

int main()
{
	char str[] = "你好";
	printf("%d\n", (int)sizeof(str));
	printf("%d\n", (int)strlen(str));
	for (int i = 0, len = strlen(str); i < len; i++)
		printf("%d ", str[i]);
}
```

C 语言中，默认使用多字节字符集（MBCS），即一个字符可能对应一个字节，也有可能对应多个字节。字符串统一用 `char` 数组保存。`strlen` 的工作原理？

参见：http://blog.sina.com.cn/s/blog_45eaa01a0102y2sh.html

注意 MBCS 描述的是字符保存方式，不描述字符与编码的对应关系。问题：如何得到实际的字符数量？（例如上例中期望的字符数量为 2）相应的，存在一个字符对应固定字节长度的编码方式，这样就很容易能获得字符串数量。

过去：使用各种不同的字符集，无法跨地区运行。

现在：使用 Unicode 字符集（UCS），编码统一。UCS 规定了字符与数的对应关系。具体的字节怎么安排，由 UTF-8，UTF-16，UTF-32 这样的具体编码规则决定。

UTF-8、UTF-16：MBCS。

UTF-32：定长。

C 语言本身不支持 Unicode。要调用外部函数实现国际化字符串处理，核心知识点是函数调用与指针。

## 第四节 动态申请内存空间

`malloc`，`free`。

```c
#include <stdlib.h>
```

`malloc` 的返回值是一个指针（`void*`）。

通过强制类型转换，将指针看作不同类型的指针。

数据保存在堆（heap）空间中。

`malloc` 和 `free` 一定要配对：

1. 使用完后一定要 `free`。
2. \*如果一个函数内部使用了 `malloc`，则一定要提供另一个函数在内部使用 `free`。

如果没有 `free`。叫做内存泄漏。程序结束运行时，操作系统会帮你回收。

如果 `free` 了错误的地址。

学习时：不要使用 `malloc` 和 `free`（没有必要）

工程中：不要使用 `malloc` 和 `free`（高级语言中，会想办法自动进行 `free` 的类似操作）

\*`malloc` 和 `free` 很慢。根据需要手动构造内存池。

## 第五节 结构体与联合体

### 第一小节 结构体

把数据结合起来。

```c
struct 类型名
{
    int a;
    int b;
    char c[10];
} 变量名1, 变量名2, ...;
```

再次定义时：

```c
struct 之前定义的类型名 变量名;
```

如果要定义很多别名，写：

```c
typedef struct // 类型名可省略
{
    int a;
    int b;
    char c[10];
} 别名1, 别名2, ...;
```

使用别名，可以省略 `struct`。

```c
别名 变量名;
```

注：C++ 中，定义结构体类型的变量时总是不用写 `struct`，所以不用纠结结构体的语法了。



原理上来说，结构体与普通变量没有区别。

```c
int main()
{
    int x;
    int y;
}
```

```c
int main()
{
    struct
    {
        int x;
        int y;
    } point;
}
```

但是结构体的组织性更强。因为结构体能够将数据组织起来，所以之后会遇到大量的结构体。

访问结构体中的元素：

```c
x.a;
```

结构体可以整体赋值，是逐字节拷贝：

```c
a = b;
```

结构体还可以作为函数参数以及返回值，所以利用结构体可以把数组提升为一等公民。

```c
#include <stdio.h>

struct Array
{
	int x[100];
};

// 返回反转后的数组。
struct Array reverse(struct Array origin)
{
	for (int i = 0, j = 99; i < 9; i++, j--)
	{
		int temp = origin.x[i];
		origin.x[i] = origin.x[j];
		origin.x[j] = temp;
	}
	return origin;
}

int main()
{
	struct Array a = { 0 }; // { 0 } 的作用是全部初始化为 0。
	for (int i = 0; i < 100; i++)
		a.x[i] = i;
	a = reverse(a);
	for (int i = 0; i < 100; i++)
		printf("%d ", a.x[i]);
}
```

注意函数的参数也存在于栈空间之中。

类型的作用域？先定义后使用。

以上程序调用函数时，参数也占一份空间，如果没有这个必要，可以只传递指针。

```c
#include <stdio.h>

struct Array
{
	int x[100];
};

// 反转指针指向的数组
void reverse(struct Array* origin)
{
	for (int i = 0, j = 99; i < 9; i++, j--)
	{
		int temp = origin->x[i];
		origin->x[i] = origin->x[j];
		origin->x[j] = temp;
	}
}

int main()
{
	struct Array a = { 0 }; // { 0 } 的作用是全部初始化为 0。
	for (int i = 0; i < 100; i++)
		a.x[i] = i;
	reverse(&a);
	for (int i = 0; i < 100; i++)
		printf("%d ", a.x[i]);
}
```

可见，对于指向结构体的指针，可以直接写 `x->a`，效果等同于 `(*x).a`。

### 第二小节 联合体

语法上结构体与联合体类似。

利用指针可以强制以整数的角度观察浮点数。

```c
#include <stdio.h>

int main()
{
	float f = 1.0f;
	int* p = (int*)(&f);
	printf("%x\n", *p);
}
```

但指针是危险的。联合体允许将存储器的一部分以不同的方式看待。

```c
#include <stdio.h>

int main()
{
	union // 类型名可省略。
	{
		int i;
		float f;
	} observe;
	printf("%d\n", (int)sizeof(observe)); // 最长的那个。
	observe.f = 1.0f; // 以浮点数的角度赋值。
	printf("%x\n", observe.i); // 以整数的角度输出。
}
```

